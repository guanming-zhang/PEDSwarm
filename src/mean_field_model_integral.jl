include("finite_diff.jl")
include("potentials.jl")
include("utils.jl")

import Base.joinpath
using SparseArrays
using JSON
using Serialization
using InteractiveUtils
using Base.Threads
using DifferentialEquations
using LinearAlgebra
using Plots

mutable struct NumericalMeanField2D
    rng::Array{Float64,1}         # size of the domain is rng[1] by rng[2] for [0,rng[1]]*[0,rng[2]]
    npts::Array{Integer,1}        # number of points per dimension npts
    delta::Array{Float64,1}       # spatial discritization 
    time_scheme::String           # forward-euler or predictor-corrector
    params::Dict{String,Float64}  # model parameters
    dt::Float64                   # time step
    step_counter::Integer         # counter for the current steps
    # model variables
    x::Array{Float64,1}           # x coordinate 
    y::Array{Float64,1}           # y coordinate
    mesh_x::Array{Float64,2}      # meshgrid for x
    mesh_y::Array{Float64,2}      # meshgrid for y
    Dx::Array{SparseMatrixCSC{Float64, Int64},1} #blockwise sparse difference matrix
    Dy::Array{SparseMatrixCSC{Float64, Int64},1} #blockwise sparse difference matrix

    # model variables
    rho::Array{Float64,1}         # density, a vector of N*N points (N = rng[1]*rng[2])
    drho::Array{Float64,1}        # change of density at each step
    grad_potential::Array{Float64,2}   # the potential gradient
    potential_flux::Array{Float64,2} # the flux generated by the potential
    center_of_mass::Array{Float64, 1} # center  of mass 
    v::Array{Float64,2}           # velocity, a 2*(N^2) matrix N^2-elements maxtrix (vx,vy)
    j::Array{Float64,2}           # j energy flux, a 2*(N^2) matrix j = rho*velocity
    t::Float64                    # time elapsed
    # auxiliary variables
    rho_store::Array{Float64,1}         # an intermediate variable for predictor-corrector scheme
    drho_store::Array{Float64,1}        # an intermediate varialbe for predictor-corrector scheme
    # auxiliary variables for reducing runtime memory allocation 
    # usage: grad_mu_fd[thread_id][lattice_index]
    
    # flag variables
    is_initialized::Bool          # a flag showing if the initial condition is set
    is_parameters_set::Bool       # a flag showing if the parameters are set 
    # Julia integrator(initilaized as nothing)
    integrator::Any                 
end

function NumericalMeanField2D(x_max, y_max, nx, ny, dt, t_scheme="forward-Euler")
    rng = [x_max, y_max]
    npts = [nx, ny]
    delta = [x_max / (nx-1.0), y_max / (ny - 1.0)]
    time_scheme = t_scheme
    params = Dict{String,Float64}()
    step_counter = 0
    t = 0
    x = range(0.0, x_max;length = nx)
    y = range(0.0, y_max;length = ny)
    mesh_x = repeat(x, 1, length(y))
    mesh_y = repeat(transpose(y), length(x), 1)
    #initialize the difference matrix
    Dx = diff_mat2D(nx, ny, 1, "forward") / delta[1]
    Dx = diff_mat2D(nx, ny, 2, "forward") / delta[2]

    #=
    Dx = diff_mat2D(nx, ny, 1, 1) / delta[1]
    Dy = diff_mat2D(nx, ny, 2, 1) / delta[2]
    Dxy = Dx * Dy
    Dxx = diff_mat2D(nx, ny, 1, 2) / (delta[1]^2)
    Dyy = diff_mat2D(nx, ny, 2, 2) / (delta[2]^2)
    cdiff_mat = Dict((1, 0) => Dx, (0, 1) => Dy, (2, 0) => Dxx, (0, 2) => Dyy, (1, 1) => Dxy)
    =#

    rho = zeros(Float64, nx * ny)
    drho = zeros(Float64, nx * ny)
    j = zeros(Float64, 2, nx * ny)
    v = zeros(Float64, 2, nx * ny)
    rho_store = zeros(Float64, nx * ny)
    drho_store = zeros(Float64, nx * ny)
    grad_potential= zeros(Float64, 2, nx * ny)
    potential_flux= zeros(Float64, 2, nx * ny)
    
    center_of_mass = zeros(Float64,2)

    NumericalMeanField2D(rng, npts, delta, time_scheme, params, dt, step_counter,,
        x, y, mesh_x, mesh_y, Dx, Dy, rho, drho, grad_potential,potential_flux,center_of_mass, v, j,
        t, rho_store, drho_store, false, false, nothing)
end


function set_model_params(model::NumericalMeanField2D, alpha)
    model.params["alpha"] = alpha # The strength of the attraction force
    set_kernels(model)
    model.is_parameters_set = true
end

function set_potential(model::NumericalMeanField2D)
    # hardcoded Ackley potential
    ackley_params = (20, 0.2, 2Ï€)
    ackley_center = 0.2 .* model.rng

    # shift the center of the ackley potential
    @views ackley_x = model.mesh_x .- ackley_center[1]
    @views ackley_y = model.mesh_y .- ackley_center[2]
    #=
    # visualize the potential
    potential = ackley.(ackley_x, ackley_y, Ref(ackley_params))
    heatmap(potential, title="Potential", xlabel="X index", ylabel="Y index")
    savefig("potential.png")  # Save the plot to a file

    # visualize the potential gradient
    heatmap(potential_grad_x, title="Potential Gradient X", xlabel="X index", ylabel="Y index")
    savefig("potential_grad_x.png")    
    heatmap(potential_grad_y, title="Potential Gradient X", xlabel="X index", ylabel="Y index")    
    savefig("potential_grad_y.png")
    
    grad = reshape(model.block_fdiff_mat[tuple(1, 0)][1] * reshape(potential,model.npts[1] * model.npts[2]),
                  (model.npts[1], model.npts[2]))
    heatmap(grad)
    savefig("grad_diff.png")
    =#
    potential_grad_x = ackley_grad_x.(ackley_x, ackley_y, Ref(ackley_params))
    potential_grad_y = ackley_grad_y.(ackley_x, ackley_y, Ref(ackley_params))
    model.grad_potential[1,:] = reshape(potential_grad_x,model.npts[1] * model.npts[2])
    model.grad_potential[2,:] = reshape(potential_grad_y,model.npts[1] * model.npts[2])

end


function set_initial_condition(model::NumericalMeanField2D, rho::Array{Float64,2})
    model.rho = reshape(rho, model.npts[1] * model.npts[2])
    model.rho_store = reshape(rho, model.npts[1] * model.npts[2])
    model.step_counter = 0
    model.t = 0
    # we warp the model into julia ODE solver
    # tmax = 10000.0 is a large number to make sure t is in [0,tmax]
    # To avoid out-of-memory error caused by storing a large amount of data 
    # to the computer memory, we set save_on = false to avoid the aforementioned problem 
    # and then save the data to the hard disk at a regular time interval in calculation.jl.
    if model.time_scheme == "julia-Tsit5"
        prob = ODEProblem(wrapped_update!,model.rho,(0.0,1000.0),model)
        model.integrator = init(prob,Tsit5();save_on=false)
    elseif model.time_scheme == "julia-RK4"
        prob = ODEProblem(wrapped_update!,model.rho,(0.0,1000.0),model)
        model.integrator = init(prob,RK4();save_on=false)
    elseif model.time_scheme =="julia-TRBDF2"
        prob = ODEProblem(wrapped_update!,model.rho,(0.0,1000.0),model)
        model.integrator = init(prob,TRBDF2();save_on=false) 
    end
    model.is_initialized = true
end


function update_center_of_mass!(model::NumericalMeanField2D)
    rho = reshape(model.rho,(model.npts[1],model.npts[2]))
    int_rho = simpson_int2d(rho,[0.0,model.rng[1]],[0.0,model.rng[2]])
    model.center_of_mass[1] = simpson_int2d(model.x.*rho,[0.0,model.rng[1]],[0.0,model.rng[2]]) /int_rho
    model.center_of_mass[2] = simpson_int2d(model.y.*rho,[0.0,model.rng[1]],[0.0,model.rng[2]]) / int_rho
end

function update_velocity!(model::NumericalMeanField2D):
    @views model.drho .= 0.0
    @views positions = (vec(model.mesh_x), vec(model.mesh_y))
    @views model.potential_flux .= 0.0
    int_rho = simpson_int2d(rho,[0.0,model.rng[1]],[0.0,model.rng[2]])
    rho = reshape(model.rho,(model.npts[1],model.npts[2]))
    for alpha in 1:2
        @views flux = reshape(model.potential_flux[alpha,:],model.npts[1],model.npts[2])
        @views model.potential_flux[alpha,:] .= reshape(flux*rho/int_rho, model.npts[1]*model.npts[2])
    end
    for alpha in 1:2
        @views model.v[alpha,:] .=  -model.potential_flux[alpha,:] .- model.params["alpha"] .* (positions[alpha][idx_rng] - model.center_of_mass[alpha])  
        @views model.j[alpha,:] .=  model.rho .* model.v[alpha,:]     
    end


function update_drho!(model::NumericalMeanField2D)
    @views model.drho[idx_rng] .= 0.0
    @views model[drho] .= -Dx*model.j[1,:] - Dy*model.j[2,:]
end


function update!(model::NumericalMeanField2D)
    update_center_of_mass!(model)
    update_velocity!(model)
    update_drho!(model)
end

function wrapped_update!(drho,rho,model,t)
    """
    we wrap the update_drho_parallel function to make it compatable to Julia ODE solver
    which is of the form du/dt = f(du,u,p,t) where u is the unknown, p is the parameter
    in our case we update drho/dt = wrapped_update(drhorho,model,t) where we use the model as
    the parameter
    """
    model.rho = rho
    update!(model)
    drho .= model.drho
end


function one_step(model::NumericalMeanField2D)
    if !model.is_initialized
        error("Please set the initialcondition before fowarding in time")
    elseif !model.is_parameters_set
        error("Please specify the value of model prameters before fowarding in time")
    end
    if model.time_scheme == "predictor-corrector"
        model.rho_store = copy(model.rho)
        update!(model)
        model.rho += model.drho * model.dt
        model.drho_store = copy(model.drho) # copy by value
        update_drho!(model)
        # Clip small drho
        # model.drho[abs.(model.rho) .< 1e-5] .= 0
        model.rho = model.rho_store + 0.5 * model.dt * (model.drho + model.drho_store)
    elseif model.time_scheme == "forward-Euler"
        update!(model)
        @. model.rho += model.drho .* model.dt

        #increase elapsed time by dt
        model.t += model.dt

    else
        error("one_step() only works for time-scheme = 
        [predictor-corrector, forward-Euler")
    end
    model.step_counter += 1
end 

function n_steps(model::NumericalMeanField2D,n)
    if !model.is_initialized
        error("Please set the initialcondition before fowarding in time")
    elseif !model.is_parameters_set
        error("Please specify the value of model prameters before fowarding in time")
    end

    if model.time_scheme in ["julia-Tsit5","julia-TRBDF2","julia-RK4"]
        step!(model.integrator,n*model.dt,true)
        model.rho = model.integrator.u
    else 
        error("n_steps() only works for time-scheme = 
              [julia-Tsit5, julia-TRBDF2, julia-RK4]")
    end
    model.step_counter += n
end

function save_data(model::NumericalMeanField2D, dir_str::String,compression::Bool)
    file_str = "Frame_$(model.step_counter).json"
    file_path = joinpath(dir_str, file_str)
    dict_data = Dict("rho" => model.rho, "j" => model.j, "v" => model.v,
                     "t"=>model.t,"step_num"=>model.step_counter)
    json_data = JSON.json(dict_data)
    open(file_path, "w") do f
        write(f, json_data)
    end
    if compression
        zip_file = joinpath(dir_str, "Frame_$(model.step_counter).zip")
        zip_cmd = ["zip","-m", "-j",zip_file,file_path]
        run(`$zip_cmd`)
    end
end


#############--------some notes--------############
# Try not to use boradcasting(.*) on sparse matrices
# or you will get an out-of-memory error in julia
# Try not to use indexing on sparse matrices since 
# it is very slow
###################################################

# unparalleled update function 
#=
function update_drho!(model::NumericalMeanField2D)
    laplace_rho = zeros(Float64, model.npts[1] * model.npts[2])
    for i in 1:2
        odiff = [0, 0]
        odiff[i] = 2
        laplace_rho += model.cdiff_mat[tuple(odiff...)] * model.rho
    end
    # mu is the chemical potential due to the interacting free energy
    model.mu = -2.0*model.params["A2"] * model.rho + 3.0*model.params["A3"] * model.rho .^ 2- 2.0*model.params["K"] * laplace_rho
    # calculate the free energy flux j
    for alpha in 1:2
        odiff = [0, 0]
        odiff[alpha] = 1
        grad_mu = model.cdiff_mat[tuple(odiff...)] * model.mu
        grad_rho = model.cdiff_mat[tuple(odiff...)] * model.rho
        model.j[alpha, :] = model.rho .* grad_mu / model.params["Gamma"]+model.params["T"] * grad_rho / model.params["Gamma"]
    end
    # calculate the stress
    for alpha in 1:2
        for beta in 1:2
            odiff = [0, 0]
            odiff[alpha] += 1
            odiff[beta] += 1
            # we should try to avoid boradcasting(e.g. .* ) when using sparse matrices
            # it will be out of memory error !!!
            model.sigma[alpha, beta, :] =  model.cdiff_mat[tuple(odiff...)]*model.rho
            model.sigma[alpha, beta, :] .*=  model.params["C"]*model.rho
        end
    end
    
    # calculate the force density
    fill!(model.f, 0.0)
    for alpha in 1:2
        for beta in 1:2 
            odiff = [0, 0]
            odiff[beta] = 1
            model.f[alpha,:] += model.cdiff_mat[tuple(odiff...)] * model.sigma[alpha, beta, :]
        end
    end
    fill!(model.drho, 0.0)
    for alpha in 1:2
        odiff = [0, 0]
        odiff[alpha] = 1
        model.drho += model.cdiff_mat[tuple(odiff...)] * (model.j[alpha, :] - model.f[alpha, :])
    end
end
=#
